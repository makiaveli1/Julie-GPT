import openai
import json
import os
import time
import datetime
from dotenv import load_dotenv
import logging
from .models import Chat, CustomUser
from .brain import LongTermMemory
from Prompt import julie_description

load_dotenv('keys.env')
client = openai.OpenAI()

logging.basicConfig(filename='juliebot.log', level=logging.INFO, format='%(asctime)s:%(levelname)s:%(message)s')

class Juliebot:
    def __init__(self, long_term_memory: LongTermMemory):
        self.long_term_memory = long_term_memory

    def create_assistant(self, user_name):
        # Format the description with the username
        formatted_description = julie_description.format_description(user_name)

        # Convert the formatted description to a string
        instructions = formatted_description.string_maker()

        assistant = client.beta.assistants.create(
            name=user_name,
            instructions=instructions,
            model="gpt-4-1106-preview",
        )
        logging.info(f"New assistant created for user {user_name}")
        return assistant.id

    def create_thread(self):
        thread = client.beta.threads.create()
        logging.info("New thread created")
        return thread.id

    def manage_chat_session(self, user_name, new_message, role):
        user = CustomUser.objects.filter(username=user_name).first()
        if not user:
            logging.error(f"No user found for username {user_name}")
            raise ValueError("User not found")

        chat_session, created = Chat.objects.get_or_create(user=user)
        if created or not chat_session.assistant_id:
            chat_session.assistant_id = self.create_assistant(user_name)
        if created or not chat_session.thread_id:
            chat_session.thread_id = self.create_thread()

        chat_history = chat_session.messages
        timestamp = datetime.datetime.now().isoformat()
        chat_history.append({"role": role, "message": new_message, "timestamp": timestamp})
        chat_session.messages = chat_history
        chat_session.save()
        return chat_session

    def send_message(self, task, user_name):
        try:
            chat_session = self.manage_chat_session(user_name, task, "user")
            self.long_term_memory.update_conversation_history_with_vector(user_name, "user", task)
            client.beta.threads.messages.create(
                thread_id=chat_session.thread_id,
                role="user",
                content=task,
            )
            logging.info(f"Message sent for user {user_name}: {task}")
        except Exception as e:
            logging.error(f"Error in send_message for user {user_name}: {e}")
            raise e

    def run_assistant(self, user_name):
        try:
            chat_session = Chat.objects.get(user__username=user_name)
            run = client.beta.threads.runs.create(
                thread_id=chat_session.thread_id,
                assistant_id=chat_session.assistant_id
            )
            while run.status in ["in_progress", "queued"]:
                time.sleep(1)
                run = client.beta.threads.runs.retrieve(
                    thread_id=chat_session.thread_id,
                    run_id=run.id
                )
            if run.status == "completed":
                return self.process_run_output(user_name, chat_session)
            else:
                logging.info(f"No response generated by the assistant for user {user_name}")
                return "No response generated by the assistant."
        except Exception as e:
            logging.error(f"Error in run_assistant for user {user_name}: {e}")
            raise e

    def process_run_output(self, user_name, chat_session):
        try:
            messages = client.beta.threads.messages.list(thread_id=chat_session.thread_id)
            sorted_messages = sorted(messages.data, key=lambda x: x.created_at, reverse=True)
            for message in sorted_messages:
                if message.role == "assistant":
                    text_content = message.content[0].text.value
                    self.manage_chat_session(user_name, text_content, "assistant")
                    self.long_term_memory.update_conversation_history_with_vector(user_name, "assistant", text_content)
                    logging.info(f"Assistant response retrieved: {text_content}")
                    return text_content
        except Exception as e:
            logging.error(f"Error processing run output for user {user_name}: {e}")
            raise e

    def display_sessions(self, file_path='chat_sessions.json'):
        if not os.path.exists(file_path):
            print("No sessions available.")
            logging.info("No sessions file found for display_sessions")
            return
        with open(file_path, 'r') as file:
            data = json.load(file)
        print("Available Sessions:")
        for number, session in data["sessions"].items():
            print(f"Session {number}: {session['User Name']}")
        logging.info("Sessions displayed")

    def get_session_data(self, session_number, file_path='chat_sessions.json'):
        with open(file_path, 'r') as file:
            data = json.load(file)
        session = data["sessions"].get(session_number)
        if session:
            self.assistant_id = session["Assistant ID"]
            self.thread_id = session["Thread ID"]
            logging.info(f"Session data retrieved for session {session_number}")
            return session["User Name"]
        else:
            print("Session not found.")
            logging.warning(f"Session {session_number} not found in get_session_data")
            return None

    def collect_message_history(self, user_name):
        messages = client.beta.threads.messages.list(thread_id=self.thread_id)
        message_dict = json.loads(messages.model_dump_json())
        with open(f'{user_name}_message_log.txt', 'w') as message_log:
            for message in reversed(message_dict['data']):
                text_value = message['content']
                prefix = "You: " if message['role'] == 'user' else f"{user_name}: "
                message_log.write(prefix + text_value + '\n')
        logging.info(f"Message history collected for user {user_name}")
        return f"Messages saved to {user_name}_message_log.txt"
